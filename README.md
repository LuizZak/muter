# Muter
### Automated mutation testing for Swift
## What is Mutation Testing?
From [Wikipedia](https://en.wikipedia.org/wiki/Mutation_testing):

> **Mutation testing** is used to design new software tests and evaluate the quality of existing software tests. Mutation testing involves modifying a program in small ways. Each mutated version is called a **mutant** and tests detect and reject mutants by causing the behavior of the original version to differ from the mutant. This is called **killing the mutant**. Test suites are **measured by the percentage of mutants that they kill**. New tests can be designed to kill additional mutants.

> Mutants are based on well-defined **mutation operators** that either mimic typical programming errors (such as using the wrong operator or variable name) or force the creation of valuable tests (such as dividing each expression by zero). The **purpose is to help the tester develop effective tests or locate weaknesses in the test data** used for the program or in sections of the code that are seldom or never accessed during execution. Mutation testing is a form of **white-box testing**.

## What Is Muter?
Muter is a [mutation testing](https://en.wikipedia.org/wiki/Mutation_testing) utility that is used to help you determine the quality of your test suite.
Specifically, it can help you:
- find gaps in fault/defect coverage from your test suite by identifying missing groups of tests, assertions/expectations, or test cases from your test suite
- determine if you are writing meaningful and effective assertions/expectations that withstand different code than what the test was originally written against
- assess how many tests fail as a result of one code change

With Muter, you can make sure your test suite is meeting all your requirements, fails meaningfully and clearly, and remains stable in the face of unexpected or accidental code changes.

## How Does It Work?
Instead of leveraging the bugs already present in the code, Muter will add new ones. The bugs introduced by Muter are called **mutants**.

 By introducing mutants randomly, it can strengthen your code and shine a light on potential weakness that you were unaware existed.

**NOTE**: Muter will always clean up after itself, so there's no need worry about leftover bugs. Muter always backs code up prior to making modifications to it.

### Mutation Score
A **mutation score** is provided at the end of every run of Muter. The score is the ratio of the number of mutants your test suite caught versus the total number of mutants introduced.

`mutation score = number of mutants killed / total number of mutants`

For example, if your test suite caught 50 mutants of the 75 introduced by Muter, your score would be 66. A well-engineered test suite should strive to be as close to 100 as possible.

Muter provides mutation score for your entire test suite and every file that it's able to apply a mutation operator to.

### Mutation Score vs Test Code Coverage
A mutation score differs from the test code coverage metric generated by many tools, and it's valuable to consider the two metrics alongside one another.

Test code coverage is only a metric of how much of your application code is executed in a test suite. It's possible to have 100% code coverage and a mutation score of 0. This would be a test suite that only executes code but never makes any assertions against the code.

It's not possible to have a mutation score > 0 and to have 0% code coverage. This would mean that you don't execute any of your application code in your test suite but your test suite somehow caught errors.

A **high mutation score**, with a **high amount of code coverage coverage**, indicates a very rigorous test suite; a lot of your application code is executed in your test suite, and the assertions that you're using in your test suite generally catch any mutations introduced.

A **high mutation score**, with a **low amount of code coverage**, indicates that a lot of your application code is not tested, but that which is tested has robust tests validating the logic.

A **low mutation score**, with a **high amount of code coverage**, indicates that a lot of your application code is being executed in a test, but that the tests you have written are not of a high quality.

### Example Test Report
```
*******************************
Muter finished running!

--------------------------
Applied Mutation Operators
--------------------------

These are all of the ways that Muter introduced changes into your code.

In total, Muter applied 19 mutation operators.

File                               Position                Applied Mutation Operator   Mutation Test Result
----                               --------                -------------------------   --------------------
AbsolutePositionExtensions.swift   Line: 10, Column: 24    Negate Conditionals         passed
AbsolutePositionExtensions.swift   Line: 11, Column: 55    Negate Conditionals         passed
NegateConditionalsMutation.swift   Line: 21, Column: 43    Side Effects                passed
NegateConditionalsMutation.swift   Line: 43, Column: 25    Negate Conditionals         passed
SideEffectsMutation.swift          Line: 20, Column: 97    Negate Conditionals         passed
SideEffectsMutation.swift          Line: 25, Column: 12    Negate Conditionals         passed
SideEffectsMutation.swift          Line: 62, Column: 72    Negate Conditionals         passed
SideEffectsMutation.swift          Line: 71, Column: 45    Negate Conditionals         passed
Table.swift                        Line: 36, Column: 16    Negate Conditionals         passed
Table.swift                        Line: 52, Column: 21    Negate Conditionals         passed
mutationDiscovery.swift            Line: 41, Column: 27    Negate Conditionals         passed
mutationDiscovery.swift            Line: 41, Column: 70    Negate Conditionals         passed
subCommands.swift                  Line: 19, Column: 65    Side Effects                failed
subCommands.swift                  Line: 26, Column: 68    Side Effects                failed
subCommands.swift                  Line: 42, Column: 40    Side Effects                passed
subCommands.swift                  Line: 48, Column: 43    Negate Conditionals         passed
testReportGeneration.swift         Line: 78, Column: 61    Negate Conditionals         passed
testReportGeneration.swift         Line: 95, Column: 15    Negate Conditionals         passed
testReportGeneration.swift         Line: 101, Column: 31   Negate Conditionals         failed



--------------------
Mutation Test Scores
--------------------

Mutation Score of Test Suite (higher is better): 84/100

File                               # of Applied Mutation Operators   Mutation Score
----                               -------------------------------   --------------
AbsolutePositionExtensions.swift   2                                 100
NegateConditionalsMutation.swift   2                                 100
SideEffectsMutation.swift          4                                 100
Table.swift                        2                                 100
mutationDiscovery.swift            2                                 100
subCommands.swift                  4                                 50
testReportGeneration.swift         3                                 66


```
## Installation
Muter is available through [Homebrew](https://brew.sh/). Run the following command to install Muter:

`brew install seanrolszewski/formulae/muter`

## Setup
### Muter's Configuration
You will need to create a configuration file named `muter.conf.json` in the root directory of the project you're mutation testing. To make this easy, you can run `muter init` in the root directory of your project.

The configuration looks something like this:
```
{
    "executable": "/usr/bin/xcodebuild",
    "arguments": [
        "-project",
        "ExampleApp.xcodeproj",
        "-scheme",
        "ExampleApp",
        "-sdk",
        "iphonesimulator",
        "-destination",
        "platform=iOS Simulator,name=iPhone 8",
        "test"
    ],
    "blacklist": ["AppDelegate.swift"]
}
```
### Configuration Options
- `executable` - the absolute path to the program which can run your test suite (like `xcodebuild` or `swift`)
- `arguments` - any command line arguments the executable needs to run your test suite
- `blacklist` - a list of paths, file extensions, or names you want Muter to ignore. By default, Muter ignores files or paths containing the following phrases:
    * `.build`
    * `.framework`
    * `.swiftdep`
    * `.swiftmodule`
    * `Build`
    * `Carthage`
    * `muter_tmp`
    * `Pods`
    * `Spec`
    * `Test`

    The `blacklist` option is optional.

**NOTE**: Muter uses a substring match to determine if something should be excluded.

For examples of configuration files, check out the `muter.conf.json` in the root directory of this repository, as well as the `muter.conf.json` inside the `ExampleApp` directory.

## Running Muter
Running Muter is easy! Once you've created your configuration file simply run `muter` in your terminal from any directory of the project you're mutation testing. Muter will take it from there. 

## Mutation Operators
Muter uses **mutation operators** to generate mutants in your source code. This is the list of currently available mutation operators.

### Negate Conditionals
The negate conditionals operator will invert conditional operators in your code based on this table:

Original Operator | Negated Operator
------------------|-----------------
`==`|`!=`
`!=`|`==`
`>=`|`<=`
`<=`|`>=`
`>`|`<`
`<`|`>`

The purpose of this operator is to highlight how your tests respond to changes in branching logic. A well-engineered test suite will be able to fail clearly in response to code taking a different branch than it expected.

#### Example
A negate conditionals operator will transform code like this:

```
if myValue >= 50 {
    // something happens here
}
```

to this:

```
if myValue <= 50 {
    // something happens here
}
```

## Limitations
- Muter currently only implements one mutation operator (called a Negate Conditionals mutation). More are slated to be released in future versions.
- Muter assumes you always put spaces around your operators. For example, it expects an equality check to look like

    `a == b (Muter will mutate this)`

    not like:

    `a==b (Muter won't mutate this)`
- Muter assumes you aren't putting multiple expressions on one line (and I have the opinion you shouldn't be doing this anyway). Basically, if you aren't using semicolons in your code then Muter shouldn't have an issue mutating it.
- Running Muter can be a lengthy process, so be sure to allocate enough time for the test to finish.

## Best Practices
- Commit your `muter.conf.json`
- Ensure you run Muter with no uncommitted changes. If Muter fails to finish, there’s a potential for the bugs it introduced to your code to be left behind.
- Because Muter can take a while to run, it is recommend to exclude UI or journey tests from your test suite. We recommend creating a separate schemes or targets for mutation testing. However, you should feel free to run these kinds of tests if you're okay with the longer feedback cycle.
- Don’t be dogmatic about your mutation score - in practice, 100/100 is often times not possible.

## FAQ
**What platforms does Muter support?**

Muter supports any platform that compiles and tests using `xcodebuild`, which includes iOS, macOS, tvOS, and watchOS. Prior to its first release, Muter was tested on multiple iOS and macOS codebases.

**Does Muter support UI test suites?**

Yes! However, these can be very lengthy test suites, and mutation testing can take a long time. I recommend you start using Muter only on your unit tests. Once you have a feel for interpreting mutation scores you can then ease into incorporating your longer running tests.

**Does Muter support Objective-C?**

No, not at this time. There aren't plans for Objective-C support until after Muter v1.0.0. Until then, Muter only supports Swift code. Any bridging code that's written in Swift, but ultimately calls down to Objective-C, is compatible with Muter.

**Is Muter self-hosted?**

Yes! Very early on I made the decision to make sure that Muter was able to provide insight into the development of Muter and its test suite. After all, since Muter is providing a form of automated testing, it must be as thorough and robust as possible. :P

**This is all pretty cool, but I'm nervous about running this on my own code. I mean, you're putting bugs into my work, and how do I know you're not stealing my source code?**

This is an understandable concern. If you would like to get a feel for what mutation testing is like, and how Muter performs it, I recommend cloning this repository, installing Muter, and then running Muter on the included example project and Muter itself.

Additionally, because Muter is parsing, analyzing, and modifying your source code, a decision was made to give it no network access - Muter collects no analytics, and never phones home. Feel free to look at its source code if you have concerns about this, or open an issue if you would like to have a discussion.

And lastly, make sure you look at and follow Muter's best practices to ensure the best possible experience while using Muter.
